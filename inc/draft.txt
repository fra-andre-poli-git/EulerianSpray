Here I put my previous implementation of positivity preserving filter

// This function applies the limiter given by Zhang, Shu,
// "On positivity-preserving high order discontinuous Galerkin schemes for 
// compressible Euler equations on rectangular meshes", adapted to the
// pressureless gas dynamics system of equations
template<int dim, int degree, int n_q_points_1d>
void EulerianSprayOperator<dim, degree, n_q_points_1d>::apply_positivity_limiter(
  SolutionType & solution,
  const DoFHandler<dim> & dof_handler,
  const MappingQ1<dim> & mapping,
  const FESystem<dim> & fe) const
{
  TimerOutput::Scope t(timer, "Apply positivity limiter");

  // First part: Set up a small number

  // I define a small quantity epsilon
  const Number eps = 1.0e-13;
  // I create a vector to store the values of cell averages of density
  std::vector<Number> cell_density_averages( dof_handler.get_triangulation().n_active_cells(), 0.0);

  // QGauss<dim> quadrature_formula(
  //   degree == 0 ?  1 :
  //   (degree % 2 == 1 ? (degree + 1)/2 : (degree + 2)/2));
  QGauss<dim>   quadrature_formula(std::max(1, static_cast<int>(fe.degree)*2 - 1));
  unsigned int n_q_points = quadrature_formula.size();

  FEValues<dim> fe_values (mapping,
    fe,
    quadrature_formula,
    update_values | update_JxW_values);
    
  std::vector<Vector<double> > solution_values(n_q_points,
    Vector<double>(dim+1));

  // In this loop I compute the average value of the density
  // TODO I could vectorize it using FEEvaluation instead of FEValues
  typename DoFHandler<dim>::active_cell_iterator
    cell = dof_handler.begin_active(),
    endc = dof_handler.end();
  for(; cell!=endc; ++cell)
  {
    // I store the averages that will be useful in second part
    unsigned int cell_no = cell->active_cell_index();//user_index();
    fe_values.reinit (cell);
    fe_values.get_function_values(solution, solution_values);

    cell_density_averages[cell_no] = 0.0;

    for (unsigned int q=0; q<n_q_points; ++q)
      cell_density_averages[cell_no] += solution_values[q][0] * fe_values.JxW(q);

    cell_density_averages[cell_no] /= cell->measure();

    Number eps1 = std::min(eps, cell_density_averages[cell_no]);

    if(eps1<eps)
    {
      std::ostringstream oss;
      oss << "Average density (" << cell_density_averages[cell_no]
        << ") is too little in cell " << cell_no << " which center is "<<
        cell->center();
      std::cout<<oss.str()<<std::endl;
      //AssertThrow(false, ExcMessage(oss.str()));
    }
  }

  cell = dof_handler.begin_active();

  // TODO Second part: in each cell modify density
  // TODO : this is the implementation by Felotti. Can I improve it making it
  // not dimension specific?
  // N is the number of points in the Gauss-Lobatto quadrature; for it to be
  // exact for polynomials
  unsigned int N = (degree + 3) % 2 == 0 ? (degree + 3)/2 : (degree + 4)/2;
  Quadrature<dim> quadrature_x (QGaussLobatto<1>(N), QGauss<1>(degree + 1)); // TODO why degree + 1 ?
  Quadrature<dim> quadrature_y (QGauss<1>(degree + 1), QGaussLobatto<1>(N));
  FEValues<dim> fe_values_x (mapping, fe, quadrature_x, update_values);
  FEValues<dim> fe_values_y (mapping, fe, quadrature_y, update_values);
  n_q_points = quadrature_x.size();
  std::vector<Number> density_values(n_q_points);
  std::vector<unsigned int> global_dof_indices(fe.dofs_per_cell);

  const FEValuesExtractors::Scalar density(0);

  for(; cell != dof_handler.end(); ++cell)
  {
    // Find \theta
    unsigned int cell_no = cell->active_cell_index();//user_index();
    fe_values_x.reinit(cell);
    fe_values_y.reinit(cell);

    // - find \rho_min
    Number rho_min = 1e20;
    fe_values_x[density].get_function_values(solution, density_values);
    for(unsigned int q=0; q<n_q_points; ++q)
       rho_min = std::min(rho_min, density_values[q]);
    fe_values_y[density].get_function_values(solution, density_values);
    for(unsigned int q=0; q<n_q_points; ++q)
       rho_min = std::min(rho_min, density_values[q]);

    // - compute \theta
    Number density_average = cell_density_averages[cell_no];
    // Number quotient = (density_average - eps)/(density_average - rho_min);
    // Number theta1 = std::min(quotient, 1.0);
    Number theta1 = std::clamp((density_average - eps) / std::max(density_average - rho_min, 1e-14), 0.0, 1.0);
    // Number quotient = std::fabs(density_average - eps) /
    //   (std::fabs(density_average - rho_min) + 1.0e-13);
    //   Number theta1 = std::min(quotient, 1.0);
    // Modify the solution
    cell->get_dof_indices (global_dof_indices);

    for(unsigned int i=0; i<fe.dofs_per_cell; ++i)
    {
      unsigned int comp_i = fe.system_to_component_index(i).first;
      if(comp_i == 0)
          solution(global_dof_indices[i]) = 
            theta1 * solution(global_dof_indices[i])
            + (1.0 - theta1) * density_average;
    }
  } 
}